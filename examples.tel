-- File for small illustrative telomare programs and for testing

-- Hello World example.
-- main = \input -> ("Hello, World!", 0)

-- -- refinement fail
-- main : (\x -> if x then "fail" else 0) = 1

-- Ad hoc user defined types example:
-- inclreaseMyInt = \x : (right MyInt) -> undefined

MyInt = let wrapper = \h -> ( \i -> if not i
                                    then abort "MyInt cannot be 0"
                                    else  (h, i)
                            , \i -> if dEqual (left i) h
                                    then 0 -- TODO: Ask sam is this should be 1 instead
                                    else abort "Not a MyInt"
                            )
        in wrapper (# wrapper)

increaseMyInt : (right MyInt) = \ x : (right MyInt)  -> (left MyInt) (succ (right x))

increaseMyInt0 = \ x : (right MyInt)  -> succ (right x)

s = if dEqual (right (increaseMyInt ((left MyInt) 8))) 11 then "Success" else "Failure"
f = if dEqual (right (increaseMyInt (8,8))) 11 then "Success" else "Failure" -- This doesn't fail yet

s0 = if dEqual (increaseMyInt0 ((left MyInt) 8)) 11 then "Success" else "Failure"
f0 = if dEqual (increaseMyInt0 (8,8)) 11 then "Success" else "Failure" -- This doesn't fail yet

abort0 = \str -> let x : (\y -> listPlus "abort: " str) = 1
                 in str

annotatedToNotBeAPairAndIsPair : (\x -> if x then 1 else 0) = (0,0)
annotatedToNotBeAPairAndIsPairAux = if dEqual annotatedToNotBeAPairAndIsPair 1 then "Success" else "Failure"

main = \i -> (annotatedToNotBeAPairAndIsPairAux, 0)

-- Case example
-- main =
--   let toCase = (("a string", 99),(8,"pattern-match"))
--       caseTest =
--         case toCase of
--           (0,(8,2)) -> "Failure 1"
--           ("a string",(8,x)) -> concat [x, " failure 2"]
--           (("a string", 99),(8,x)) -> concat [x, " success with ints, strings and variables"]
--   in \input -> (caseTest, 0)
